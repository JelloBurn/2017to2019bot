package org.usfirst.frc.team2461.robot;

import org.opencv.core.Rect;
import org.opencv.imgproc.Imgproc;

import edu.wpi.cscore.CvSink;
import edu.wpi.cscore.UsbCamera;
import edu.wpi.cscore.VideoSink;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.vision.VisionThread;

/**
 * This class wraps a USB camera and the TapeTracker pipeline generated by GRIP.
 * It uses the pipeline to detect 2 rectangle contours and will use the center
 * point between the two rectangles to set a center point which can be used to
 * drive robot systems
 * 
 * @author Will
 *
 */
public class Tracker
{
	private VisionThread visionThread;
	private UsbCamera cam0;
	private UsbCamera cam1;
	private CvSink cvSink0;
	private CvSink cvSink1;
	private VideoSink videoSinkMain;
	public final int IMG_WIDTH = 320;
	public final int IMG_HEIGHT = 240;
	private double center;
	private Object imgLock = new Object();
	private Object variableLock = new Object();
	private Exception e;
	private int numberofContours;
	private boolean foundTarget = false;
	private int cameraChoice = 0;
	private MetalSkinsController player;
	private boolean lastButtonState = false;
	private int exposureRegular = 50;
	private int exposureTracking = 0;
	private long counter = 0;

	public Tracker(MetalSkinsController playerIn)
	{
		cam0 = CameraServer.getInstance().startAutomaticCapture();
		cam0.setResolution(IMG_WIDTH, IMG_HEIGHT);
		cam0.setExposureManual(exposureTracking);
		cam0.setFPS(64);

		cam1 = CameraServer.getInstance().startAutomaticCapture();
		cam1.setResolution(IMG_WIDTH, IMG_HEIGHT);
		cam1.setExposureManual(exposureTracking);
		cam1.setFPS(64);

		cvSink0 = new CvSink("cam0cv");
		cvSink0.setSource(cam0);
		cvSink0.setEnabled(true);

		cvSink1 = new CvSink("cam1cv");
		cvSink1.setSource(cam1);
		cvSink1.setEnabled(false);

		videoSinkMain = CameraServer.getInstance().getServer();
		videoSinkMain.setSource(cam0);

		player = playerIn;
	}

	public double getCenter()
	{
		double center;
		synchronized (imgLock)
		{
			center = this.center;
		}
		return center;
	}

	public boolean getThreadState()
	{
		return visionThread.isAlive();
	}

	public String getException()
	{
		if (e != null)
		{
			return "No exception :-)";
		} else
		{
			return e.getMessage();
		}
	}

	public int getfilterContoursOutput()
	{
		synchronized (variableLock)
		{
			return numberofContours;
		}
	}

	public double getFromCenter()
	{
		if (getCenter() != 0)
		{
			double turn = getCenter() - (IMG_WIDTH / 2);
			return turn;
		} else
		{
			return 0;
		}
	}

	public boolean getTargetStatus()
	{
		synchronized (imgLock)
		{
			return foundTarget;
		}
	}

	private void runTrackingThread()
	{
		visionThread = new VisionThread(cam0, new TapeTracker(), pipeline -> {
			try
			{
				synchronized (variableLock)
				{
					numberofContours = pipeline.filterContoursOutput().size();
					counter++;
				}

				if (!pipeline.filterContoursOutput().isEmpty() && pipeline.filterContoursOutput().size() < 3)
				{
					Rect r1 = Imgproc.boundingRect(pipeline.filterContoursOutput().get(0));
					Rect r2 = Imgproc.boundingRect(pipeline.filterContoursOutput().get(1));
					double r1CenterX = (double) r1.x + (r1.width / 2);
					double r2CenterX = (double) r2.x + (r2.width / 2);
					synchronized (imgLock)
					{
						center = (r1CenterX + r2CenterX) / 2;
						foundTarget = true;
					}
				} else
				{
					foundTarget = false;
					synchronized (imgLock)
					{
						center = 0.0;
					}
				}
			} catch (Exception e1)
			{
				e = e1;
			}

		});

		visionThread.start();
	}

	public void startTracking()
	{
		if (visionThread == null)
		{
			setCameraTrackingModeOn();
			runTrackingThread();
		} else if (visionThread.isInterrupted() || visionThread.isAlive())
		{
			setCameraTrackingModeOn();
			runTrackingThread();
		}
		// visionThread.start();
	}

	public void stopTracking()
	{
		if (visionThread != null)
		{
			// visionThread.interrupt();
		}
		setCameraTrackingModeOff();
	}

	public void switchCameras()
	{
		if (cameraChoice == 0)
		{
			cameraChoice = 1;
			cvSink1.setEnabled(true);
			videoSinkMain.setSource(cam1);
			cvSink0.setEnabled(false);
		} else
		{
			cameraChoice = 0;
			cvSink0.setEnabled(true);
			videoSinkMain.setSource(cam0);
			cvSink1.setEnabled(false);
		}
	}

	public int getCurrentCamera()
	{
		return cameraChoice;
	}

	public String getCurrentCameraString()
	{
		if (cameraChoice == 0)
			return "Front: Gear Side";
		else
			return "Rear: Ball Collector Side";
	}

	public void run()
	{
		if (checkButtonStart())
		{
			switchCameras();
		}
	}

	private boolean checkButtonStart()
	{
		if (player.getStartButton() && !lastButtonState)
		{
			lastButtonState = true;
			return true;
		} else if (player.getStartButton() && lastButtonState)
		{
			return false;
		} else
		{
			lastButtonState = false;
			return false;
		}
	}

	private void setCameraTrackingModeOn()
	{
		cam0.setExposureManual(exposureTracking);
		cam0.setFPS(64);

		cam1.setExposureManual(exposureTracking);
		cam1.setFPS(64);
	}

	private void setCameraTrackingModeOff()
	{
		cam0.setExposureManual(exposureRegular);
		cam0.setFPS(30);

		cam1.setExposureManual(exposureRegular);
		cam1.setFPS(30);
	}
	
	public long getCounter()
	{
		synchronized(variableLock)
		{
			return counter;
		}
	}
}
